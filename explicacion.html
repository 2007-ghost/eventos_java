<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Demos de Eventos en JavaScript — Explicado paso a paso</title>
  <style>
    :root {
      --bg1: #00c6ff;
      --bg2: #0072ff;
      --panel: rgba(0, 0, 0, .35);
      --text: #fff;
      --muted: #e2e8f0;
      --code-bg: #0f172a;
      --card: #1e293b;
      --accent: #38bdf8;
    }

    * {
      box-sizing: border-box
    }

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(to right, var(--bg1), var(--bg2));
      color: var(--text);
      margin: 0;
      padding: 20px;
    }

    h1,
    h2 {
      text-align: center;
      margin: 10px 0 14px
    }

    .section {
      margin: 40px auto;
      padding: 20px;
      border-radius: 15px;
      background: var(--panel);
      max-width: 1000px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, .3);
    }

    .board {
      display: grid;
      grid-template-columns: repeat(3, 100px);
      grid-template-rows: repeat(3, 100px);
      gap: 6px;
      justify-content: center;
      margin: 18px auto;
    }

    .cell,
    .puzzle-cell {
      background: #fff;
      color: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 2rem;
      font-weight: 700;
      cursor: pointer;
      border-radius: 12px;
      transition: background .25s;
      user-select: none;
    }

    .cell:hover,
    .puzzle-cell:hover {
      background: #dbeafe
    }

    .winner {
      text-align: center;
      font-size: 1.25rem;
      font-weight: 800;
      margin-top: 8px
    }

    /* Bloques de explicación */
    .explanation {
      background: var(--card);
      padding: 18px;
      border-radius: 12px;
      margin: 16px auto 0;
    }

    .explanation h3 {
      color: var(--accent);
      margin-top: 10px
    }

    .explanation p {
      color: var(--muted)
    }

    pre {
      background: var(--code-bg);
      color: #e5e7eb;
      padding: 12px;
      border-radius: 10px;
      overflow: auto;
    }

    code {
      background: rgba(255, 255, 255, .08);
      padding: 2px 6px;
      border-radius: 6px
    }

    /* Flechas de scroll */
    .scroll-arrows {
      position: fixed;
      right: 20px;
      bottom: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      opacity: 0;
      transition: opacity .35s ease;
      pointer-events: none;
      z-index: 9999;
    }

    .arrow {
      background: #fff;
      color: #000;
      width: 44px;
      height: 44px;
      display: grid;
      place-items: center;
      border-radius: 50%;
      font-size: 1.5rem;
      box-shadow: 0 10px 25px rgba(0, 0, 0, .35);
    }
  </style>
</head>

<body>

  <h1>Ejercicios de Eventos en JavaScript (con explicaciones)</h1>
  <!-- ============ EJERCICIO 1: ROMPECABEZAS 3x3 (TECLADO) ============ -->
  <section class="section" id="ej2">
    <h2>Ejercicio 1: Rompecabezas 3×3 (evento <code>keydown</code>)</h2>
    <p style="text-align:center;margin:0 0 10px">
      Usa ⬆️ ⬇️ ⬅️ ➡️ para mover el <em>espacio vacío</em>. Orden objetivo: 1–8 y el vacío al final.
    </p>
    <div class="board" id="puzzle"></div>

    <div class="explanation">
      <h3>¿Qué vas a aprender?</h3>
      <p>
        A escuchar el <strong>teclado</strong> con <code>addEventListener("keydown", ...)</code>, a representar
        el estado del puzzle en un arreglo, a renderizar la grilla desde ese estado y a mover
        el espacio vacío intercambiándolo con una ficha <em>adyacente</em> según la flecha pulsada.
      </p>

      <h3>1) Estado del juego y barajado inicial</h3>
      <p>Representamos el tablero como un arreglo de 9 posiciones; <code>""</code> es el vacío:</p>
      <pre><code>const puzzle = document.getElementById("puzzle");
let pieces = [1,2,3,4,5,6,7,8,""]; // 8 fichas + 1 vacío

// Pequeño barajado simple para demo (no garantiza resolubilidad matemática)
function shuffle(arr) {
  arr.sort(() => Math.random() - 0.5);
}
shuffle(pieces);
</code></pre>

      <h3>2) Renderizar el tablero desde el arreglo</h3>
      <p>Cada valor del arreglo se vuelca a una <code>.puzzle-cell</code>:</p>
      <pre><code>function renderPuzzle() {
  puzzle.innerHTML = "";
  pieces.forEach(p =&gt; {
    const cell = document.createElement("div");
    cell.classList.add("puzzle-cell");
    cell.textContent = p; // cadena vacía si es el hueco
    puzzle.appendChild(cell);
  });
}
renderPuzzle();
</code></pre>

      <h3>3) Escuchar las teclas de flecha</h3>
      <p>Dependiendo de la flecha, intentamos mover el vacío intercambiándolo con la ficha vecina:</p>
      <pre><code>document.addEventListener("keydown", (e) => {
  if (e.key === "ArrowUp")    mover("up");
  if (e.key === "ArrowDown")  mover("down");
  if (e.key === "ArrowLeft")  mover("left");
  if (e.key === "ArrowRight") mover("right");
});
</code></pre>

      <h3>4) Reglas de movimiento (adyacencia y límites)</h3>
      <p>
        Calculamos índice del vacío, su fila y columna. Solo hay movimiento si existe
        vecino válido en esa dirección (nos cuidamos de no “saltar” de fila a fila).
      </p>
      <pre><code>function mover(direction) {
  const emptyIndex = pieces.indexOf("");
  const row = Math.floor(emptyIndex / 3);
  const col = emptyIndex % 3;

  let swapIndex = null;
  if (direction === "up"    && row &lt; 2) swapIndex = emptyIndex + 3; // subir hueco = traer ficha de abajo
  if (direction === "down"  && row &gt; 0) swapIndex = emptyIndex - 3;
  if (direction === "left"  && col &lt; 2) swapIndex = emptyIndex + 1;
  if (direction === "right" && col &gt; 0) swapIndex = emptyIndex - 1;

  if (swapIndex !== null) {
    [pieces[emptyIndex], pieces[swapIndex]] = [pieces[swapIndex], pieces[emptyIndex]];
    renderPuzzle();
  }
}
</code></pre>
    </div>
  </section>
  <!-- ================= EJERCICIO 2: TRIQUI (CLICK) ================= -->
  <section class="section" id="ej1">
    <h2>Ejercicio 2: Triqui (evento <code>click</code>)</h2>
    <div class="board" id="board"></div>
    <div class="winner" id="winner"></div>

    <div class="explanation">
      <h3>¿Qué vas a aprender?</h3>
      <p>
        A reaccionar a <strong>clics</strong> en celdas usando <code>addEventListener("click", ...)</code>,
        a alternar turnos (<code>X</code> y <code>O</code>) y a detectar una victoria
        comparando contra patrones ganadores (filas, columnas y diagonales).
      </p>

      <h3>1) Crear el tablero 3×3 dinámicamente</h3>
      <p>Generamos 9 celdas y las agregamos al contenedor <code>#board</code>:</p>
      <pre><code>// Referencias
const board = document.getElementById("board");
const winnerDisplay = document.getElementById("winner");
let currentPlayer = "X";
let gameOver = false;

// Generar las 9 casillas
for (let i = 0; i &lt; 9; i++) {
  const cell = document.createElement("div");
  cell.classList.add("cell");
  board.appendChild(cell);

  // (en el paso 2 añadimos el listener de click)
}
</code></pre>

      <h3>2) Escuchar clics y colocar la marca</h3>
      <p>Solo se marca si la celda está vacía y el juego no terminó:</p>
      <pre><code>cell.addEventListener("click", () => {
  if (cell.textContent === "" && !gameOver) {
    cell.textContent = currentPlayer;   // pinta X u O
    checkWinner();                      // revisa victoria tras cada jugada
    currentPlayer = currentPlayer === "X" ? "O" : "X"; // alterna turno
  }
});
</code></pre>

      <h3>3) Patrones ganadores (8 combinaciones)</h3>
      <p>Comparamos el contenido de las celdas en filas, columnas y diagonales:</p>
      <pre><code>const winPatterns = [
  [0,1,2], [3,4,5], [6,7,8], // filas
  [0,3,6], [1,4,7], [2,5,8], // columnas
  [0,4,8], [2,4,6]           // diagonales
];</code></pre>

      <h3>4) Comprobar ganador y mostrar el mensaje</h3>
      <p>Si todas las posiciones del patrón tienen la misma marca, hay ganador:</p>
      <pre><code>function checkWinner() {
  const cells = document.querySelectorAll(".cell");
  const winPatterns = [
    [0,1,2], [3,4,5], [6,7,8],
    [0,3,6], [1,4,7], [2,5,8],
    [0,4,8], [2,4,6]
  ];

  for (let pattern of winPatterns) {
    const [a, b, c] = pattern;
    if (
      cells[a].textContent &&
      cells[a].textContent === cells[b].textContent &&
      cells[a].textContent === cells[c].textContent
    ) {
      winnerDisplay.textContent = `¡Jugador ${cells[a].textContent} gana!`;
      gameOver = true;
      return;
    }
  }
}
</code></pre>
    </div>
  </section>
  <script>
    /* ===== EJERCICIO 1: TRIQUI ===== */
    const board = document.getElementById("board");
    const winnerDisplay = document.getElementById("winner");
    let currentPlayer = "X";
    let gameOver = false;

    for (let i = 0; i < 9; i++) {
      const cell = document.createElement("div");
      cell.classList.add("cell");
      board.appendChild(cell);

      // Evento click en cada celda
      cell.addEventListener("click", () => {
        if (cell.textContent === "" && !gameOver) {
          cell.textContent = currentPlayer;
          checkWinner();
          currentPlayer = currentPlayer === "X" ? "O" : "X";
        }
      });
    }

    function checkWinner() {
      const cells = document.querySelectorAll(".cell");
      const winPatterns = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],
        [0, 3, 6], [1, 4, 7], [2, 5, 8],
        [0, 4, 8], [2, 4, 6]
      ];

      for (let pattern of winPatterns) {
        const [a, b, c] = pattern;
        if (
          cells[a].textContent &&
          cells[a].textContent === cells[b].textContent &&
          cells[a].textContent === cells[c].textContent
        ) {
          winnerDisplay.textContent = `¡Jugador ${cells[a].textContent} gana!`;
          gameOver = true;
          return;
        }
      }
    }

    /* ===== EJERCICIO 2: ROMPECABEZAS (mover vacío con flechas) ===== */
    const puzzle = document.getElementById("puzzle");
    let pieces = [1, 2, 3, 4, 5, 6, 7, 8, ""]; // 8 casillas ocupadas + 1 libre

    function shuffle(arr) { arr.sort(() => Math.random() - 0.5); }
    shuffle(pieces);

    function renderPuzzle() {
      puzzle.innerHTML = "";
      pieces.forEach(p => {
        const cell = document.createElement("div");
        cell.classList.add("puzzle-cell");
        cell.textContent = p; // vacío = cadena ""
        puzzle.appendChild(cell);
      });
    }
    renderPuzzle();

    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowUp") mover("up");
      if (e.key === "ArrowDown") mover("down");
      if (e.key === "ArrowLeft") mover("left");
      if (e.key === "ArrowRight") mover("right");
    });

    function mover(direction) {
      const emptyIndex = pieces.indexOf("");
      const row = Math.floor(emptyIndex / 3);
      const col = emptyIndex % 3;

      let swapIndex = null;
      if (direction === "up" && row < 2) swapIndex = emptyIndex + 3; // traer ficha de abajo
      if (direction === "down" && row > 0) swapIndex = emptyIndex - 3;
      if (direction === "left" && col < 2) swapIndex = emptyIndex + 1;
      if (direction === "right" && col > 0) swapIndex = emptyIndex - 1;

      if (swapIndex !== null) {
        [pieces[emptyIndex], pieces[swapIndex]] = [pieces[swapIndex], pieces[emptyIndex]];
        renderPuzzle();
      }
    }
  </script>
</body>

</html>